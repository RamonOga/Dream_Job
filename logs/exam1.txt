[1. Что такое сервлет?](#1-Что-такое-сервлет)
[2. Какова структура веб-проекта?] (#Какова-структура-веб-проекта?)
[3. Что такое контейнер сервлетов?] (#Что-такое-контейнер-сервлетов?)
[4. Каковы задачи, функциональность контейнера сервлетов?] (#Каковы-задачи,-функциональность-контейнера-сервлетов?)
[5. Что вы знаете о сервлет фильтрах?] (#Что-вы-знаете-о-сервлет-фильтрах?)
[6. Зачем нужны слушатели в сервлетах?] (#Зачем-нужны-слушатели-в-сервлетах?)
[7. Когда вы будете использовать фильтры, а когда слушатели?] (#Когда-вы-будете-использовать-фильтры,-а-kогда-слушатели?)
[8. Как обработать исключения, выброшенные другим сервлетом в приложении?] (#Как-обработать-исключения,-выброшенные-другим-сервлетом-в-приложении?)
9. Что такое дескриптор развертывания?
10. Как реализовать запуск сервлета с запуском приложения?
11. Что представляет собой объект ServletConfig?
12. Что представляет собой объект ServletContext?
13. В чем отличия ServletContext и ServletConfig?
14. Что такое Request Dispatcher?
15. Как можно создать блокировку (deadlock) в сервлете?
16. Как получить адрес сервлета на сервере?
17. Как получить информацию о сервере из сервлета?
18. Как получить ip адрес клиента на сервере?
19. Что вы знаете о классах обертках (wrapper) для сервлетов?
20. Каков жизненный цикл сервлета и когда какие методы вызываются?
21. Какие методы необходимо определить при создании сервлетов?
22. В каком случае вы будете переопределять метод service()?
23. Есть ли смысл определить конструктор для сервлета, как лучше инициализировать данные?
24. В чем отличия GenericServlet и HttpServlet?
25. Как вызвать из сервлета другой сервлет этого же и другого приложения?
26. Что вы знаете и в чем отличия методов forward() и sendRedirect()?
27. Стоит ли волноваться о “многопоточной безопасности” работая с сервлетами?
28. В чем отличие между веб сервером и сервером приложений?
29. Какой метод HTTP не является неизменяемым?
30. Почему HttpServlet класс объявлен как абстрактный?
31. В чем разница между методами GET и POST?
32. Что такое MIME-тип?
33. Назовите преимущества Servlet над CGI?
34. Каковы наиболее распространенные задачи выполняются в Servlet контейнере?
35. В чем разница между PrintWriter и ServletOutputStream?
36. Можем ли мы получить PrintWriter и ServletOutputStream одновременно в сервлете?
37. Расскажите о интерфейсе SingleThreadModel.
38. Какие существуют атрибуты у сервлетов и какая сфера их применения?
39. Почему необходимо переопределить только init() метод без аргументов?
40. Что означает URL encoding? Зачем нужны методы java.net.URLEncoder.encode() и decode()?
41. Зачем нужны и чем отличаются методы encodeUrl() и encodeRedirectUrl()?
42. Какие различные методы управления сессией в сервлетах вы знаете?
43. Что означает URL Rewriting?
44. Как применяются Cookies в сервлетах?
45. Как уведомить объект в сессии, что сессия недействительна или закончилась?
46. Какой существует эффективный способ удостоверится, что все сервлеты доступны только для пользователя с валидной сессией?
47. Как мы можем обеспечить transport layer security для нашего веб приложения?
48. Как организовать подключение к базе дынных и обеспечить логирование log4j в сервлете?
49. Какие важные особенности существуют в Servlet 3?
50. Каковы различные способы аутентификации сервлета?
51. Написать сервлет, реализующий загрузку файла на сервер.

## 1. Что такое сервлет?

Сервлет - это просто класс, который отвечает на определенный тип сетевого запроса-чаще всего на запрос HTTP.
В основном servlets обычно используются для реализации веб - приложений, но существуют также различные фреймворки,
 которые работают поверх servlets (например, Struts), чтобы дать абстракцию более высокого уровня, чем уровень "here's an HTTP request,
  write to this HTTP response", который обеспечивает servlets.

Servlets Выполняется в контейнере сервлетов , который обрабатывает сетевую сторону (например, анализ запроса HTTP, обработка соединений и т. Д.).
 Одним из самых известных контейнеров сервлетов с открытым исходным кодом является Tomcat .

 ## 2. Какова структура веб-проекта?

 Все зависит от фреймворка. В каждом фреймворке свои правила разделения. Все файлы находятся в папке src. Тесты, веб.файлы, java-код и т.д. в отдельных папках.
 Java-классы разделены в соответствии с бизнес логикой. storage, model, servlet и т.д.

 ## 3. Что такое контейнер сервлетов?

 Контейнер сервлетов  — программа, представляющая собой сервер, который занимается системной поддержкой сервлетов и обеспечивает
  их жизненный цикл в соответствии с правилами, определёнными в спецификациях.

## 4. Каковы задачи, функциональность контейнера сервлетов?

Контейнер сервлетов может работать как полноценный самостоятельный веб-сервер, быть поставщиком страниц для другого веб-сервера, например Apache, или интегрироваться в Java EE сервер приложений.
 Обеспечивает обмен данными между сервлетом и клиентами, берёт на себя выполнение таких функций, как создание программной среды для функционирующего сервлета, идентификацию и авторизацию клиентов,
  организацию сессии для каждого из них.


## 5. Что вы знаете о сервлет фильтрах?

Сервлетный фильтр, в соответствии со спецификацией, это Java-код, пригодный для повторного использования и позволяющий преобразовать содержание HTTP-запросов, HTTP-ответов и информацию, содержащуюся в заголовках HTTP. Сервлетный фильтр занимается предварительной обработкой запроса, прежде чем тот попадает в сервлет, и/или последующей обработкой ответа, исходящего из сервлета.Сервлетные фильтры могут:

– перехватывать инициализацию сервлета прежде, чем сервлет будет инициирован;
– определить содержание запроса прежде, чем сервлет будет инициирован;
– модифицировать заголовки и данные запроса, в которые упаковывается поступающий запрос;
– модифицировать заголовки и данные ответа, в которые упаковывается получаемый ответ;
– перехватывать инициализацию сервлета после обращения к сервлету.

Сервлетный фильтр может быть сконфигурирован так, что он будет работать с одним сервлетом или группой сервлетов. Основой для формирования фильтров служит интерфейс javax.servlet.Filter, который реализует три метода:
void init (FilterConfig config) throws ServletException;
void destroy();
void doFilter (ServletRequest request, ServletResponse response, FilterChain chain) throws IOException, ServletException;

Метод init() вызывается прежде, чем фильтр начинает работать,и настраивает конфигурационный объект фильтра. Метод doFilter выполняет непосредственно работу фильтра. Таким образом, сервер вызывает init() один раз, чтобы запустить фильтр в работу, а затем вызывает doFilter() столько раз, сколько запросов будет сделано непосредственно к данному фильтру. После того, как фильтр заканчивает свою работу, вызывается метод destroy().

Java Servlet Filter Example Tutorial: http://www.journaldev.com/1933/java-servlet-filter-example-tutorial

## 6. Зачем нужны слушатели в сервлетах?

Слушатели контекста и сессий – это классы, которые могут следить за тем, когда контекст или сессия были инициализированы, или отслеживать время, когда они должны быть уничтожены,
и когда атрибуты были добавлены или удалены из контекста или сессии. Servlet 2.4 расширяет модель слушателей запроса, позволяя отслеживать, как запрос создается и уничтожается, и,
 как атрибуты добавляются и удаляются из сервлета В Servlet 2.4 добавлены следующие классы:

ServletRequestListener
ServletRequestEvent
ServletRequestAttributeListener
ServletRequestAttributeEvent

## 7. Когда вы будете использовать фильтры, а когда слушатели?

Слушатели для реацкии на события. Фильтры для фильтрации запросов.

Фильтры используются для запросов до и после процесса. Посмотрите javax.servlet.Filter в своем tomcat/jboss/другой контейнер javadoc.

Если слушатели похожи на триггеры, которые могут быть привязаны к событиям в ваш сервер приложений (используйте здесь контейнер термина).
С помощью слушателей вы можете отслеживать изменения на уровне приложений, сеанса, изменения жизненного цикла, изменения атрибутов и т.д. Реализованные интерфейсы -
 это интерфейс javax.servlet.Listener.
 Основываясь на приведенных ниже ответах @fnt, позвольте мне попытаться прояснить еще кое-что. Прослушиватели предназначены для изменений жизненного цикла без необходимости получения запроса клиента.
 Таким образом, для одного запроса клиента может произойти гораздо больше событий жизненного цикла, прежде чем запрос будет удален. Пример: Вы хотите зарегистрировать все сеансы, которые истекли.
 Обратите внимание, что SesionTimeout-это событие жизненного цикла, которое может произойти без участия пользователя. Для такого сценария подойдет слушатель.

 К вопросу о регистрации при поступлении запроса. Нет прямого сопоставления нового запроса с эквивалентным событием прослушивателя (событие жизненного цикла чтения). И, следовательно, для каждого
 входящего запроса, если вы хотите что-то зарегистрировать, фильтр, на мой взгляд, является правильным.

 ## 8. Как обработать исключения, выброшенные другим сервлетом в приложении?